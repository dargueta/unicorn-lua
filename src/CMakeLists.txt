# Build a list of the installed header files and strip the stems out so that we
# can generate the corresponding *_const.cpp files from them. This way, we don't
# make assumptions about which architectures the user has built and we don't need
# to change the code when Unicorn adds new architectures.
file(GLOB INSTALLED_ARCH_HEADERS "${UNICORN_INCDIR}/unicorn/*.h")
foreach(path IN ITEMS ${INSTALLED_ARCH_HEADERS})
    cmake_path(GET path STEM LAST_ONLY CURRENT_SLUG)
    # platform.h is not of interest to us.
    if(NOT CURRENT_SLUG STREQUAL "platform")
        list(APPEND HEADER_SLUGS "${CURRENT_SLUG}")
    endif()
endforeach()


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~ Define dependencies ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

# Build a list of the .cpp files that need to be autogenerated with all the
# architecture-specific values. This takes the architecture slugs and turns them into
# file paths.
list(
    TRANSFORM HEADER_SLUGS
    PREPEND "${CMAKE_CURRENT_SOURCE_DIR}/constants/"
    OUTPUT_VARIABLE _const_files
)
list(TRANSFORM _const_files APPEND "_const.cpp")


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Define targets ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

file(MAKE_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/constants")

# Create commands for autogenerating all the constants files.
foreach(_slug IN ITEMS ${HEADER_SLUGS})
    set(_file "${CMAKE_CURRENT_SOURCE_DIR}/constants/${_slug}_const.cpp")
    add_custom_command(
        OUTPUT "${_file}"
        COMMAND "python3" "${PROJECT_SOURCE_DIR}/tools/generate_constants.py" "${UNICORN_INCDIR}/unicorn/${_slug}.h" "${_file}"
        WORKING_DIRECTORY "${PROJECT_SOURCE_DIR}"
    )
endforeach()

add_library(unicornlua_library SHARED
    ${_const_files}
    "${CMAKE_CURRENT_SOURCE_DIR}/compat.cpp"
    "${CMAKE_CURRENT_SOURCE_DIR}/context.cpp"
    "${CMAKE_CURRENT_SOURCE_DIR}/engine.cpp"
    "${CMAKE_CURRENT_SOURCE_DIR}/errors.cpp"
    "${CMAKE_CURRENT_SOURCE_DIR}/hooks.cpp"
    "${CMAKE_CURRENT_SOURCE_DIR}/memory.cpp"
    "${CMAKE_CURRENT_SOURCE_DIR}/registers.cpp"
    "${CMAKE_CURRENT_SOURCE_DIR}/registers_const.cpp"
    "${CMAKE_CURRENT_SOURCE_DIR}/unicorn.cpp"
    "${CMAKE_CURRENT_SOURCE_DIR}/utils.cpp"
)

target_include_directories(
    unicornlua_library
    PRIVATE
    "${PROJECT_SOURCE_DIR}/include"
)

# Override the default naming for the library. On POSIX systems the prefix "lib" is
# added, and the default name (without the prefix) uses the project name. We want the
# output file to be `unicorn.dll` on Windows, `unicorn.so` everywhere else.
set_target_properties(
    unicornlua_library PROPERTIES
    PREFIX ""
    OUTPUT_NAME "unicorn"
    SUFFIX "${LIBRARY_FILE_EXTENSION}"
)


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~ Set compiler options ~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

# Apparently OSX requires this stuff: https://stackoverflow.com/q/42371892
if (APPLE)
    target_link_options(unicornlua_library BEFORE PUBLIC -undefined dynamic_lookup)
endif()

# For some reason this is required only for LuaJIT on *NIX platforms except OSX.
if(IS_LUAJIT AND UNIX AND (NOT APPLE))
    target_link_libraries(unicornlua_library PUBLIC dl)
endif()

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Installation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #

# Override the default destination. Normally it's ${CMAKE_INSTALL_PREFIX} plus
# a platform-specific directory like "lib", "include", or "bin". We don't want
# those, so we have to override the entire destination.
if(WIN32)
    install(TARGETS unicornlua_library RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}")
elseif(UNIX)
    install(TARGETS unicornlua_library LIBRARY DESTINATION "${CMAKE_INSTALL_PREFIX}")
    target_link_libraries(unicornlua_library PUBLIC pthread)
else()
    message(FATAL_ERROR "Unsupported target OS: ${CMAKE_SYSTEM_NAME}")
endif()
