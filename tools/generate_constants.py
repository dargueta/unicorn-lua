"""Generate constants files from the Unicorn headers.

This is heavily borrowed from the script in the Unicorn source repo, except modified to
work with an installed library rather than from the source code. The headers must be
present, but that's all that's required.
"""

import ast
import collections
import datetime
import logging
import os
import re
import sys


GENERATED_FILE_TEMPLATE = """\
/** Autogenerated from installed Unicorn header files. DO NOT EDIT.
 *
 * Source: {header_file}
 * Generated: {now:%Y-%m-%d %I:%M %p}
 *
 * @file {slug}_const.cpp
 */

#include <unicorn/unicorn.h>

#include "unicornlua/lua.h"
#include "unicornlua/utils.h"

static const struct NamedIntConst kConstants[] {{
{values},
    {{nullptr, 0}}
}};

extern "C" UNICORN_EXPORT int luaopen_unicorn_{slug}_const(lua_State *L) {{
    lua_createtable(L, 0, {n_values});
    load_int_constants(L, kConstants);
    return 1;
}}
"""


def clean_line(line):
    """Strip whitespace off a line and separate out the comment, if any."""
    if "//" in line:
        line, _sep, comment = line.partition("//")
    if "/*" in line:
        line, _sep, comment = line.partition("/*")
        comment, _sep, _trash = comment.partition("*/")
    else:
        comment = ""

    return line.strip(), comment.strip()


def parse_header_file(header_file):
    """Parse a single header file to get all defined constants out of it."""
    resolved_values = collections.OrderedDict()
    raw_matches = {}

    with open(header_file, "r") as fd:
        all_file_lines = collections.OrderedDict(
            [
                (lineno, line.strip())
                for lineno, line in enumerate(fd, start=1)
                if not line.isspace()
            ]
        )

    line_iterator = iter(all_file_lines.items())

    for lineno, line in line_iterator:
        line, _comment = clean_line(line)

        # First check to see if this is a #define statement
        match = re.match(r"^#define\s+UC_(?P<id>\w+)\s+(?P<value>.*)$", line)
        if match:
            name = "UC_" + match.group("id")
            raw_value = match.group("value")
            try:
                resolved_values[name] = ast.literal_eval(raw_value)
            except (NameError, SyntaxError, ValueError):
                raw_matches[name] = raw_value
            continue

        # Not a #define; see if it's an enum.
        if "enum uc_" not in line.lower():
            continue

        # This is the beginning of an enum. Subsequent lines until the closing `}` are
        # part of it. We need to keep track because enums without an explicitly defined
        # value are incremented by one from the previous enum value.
        next_enum_value = 0
        enum_start_line = lineno
        while True:
            lineno, line = next(line_iterator, (None, None))
            if line is None:
                # Hit EOF before we hit the end of the enum. That's odd.
                logging.warning(
                    "Hit EOF before end of enum beginning on line %d.", enum_start_line
                )
                break
            elif "}" in line:
                # Hit the end of the enum.
                break

            line, _comment = clean_line(line)

            # Sometimes we have multiple enum definitions on one line. We need to handle
            # these one at a time. Splitting the line by commas should be enough to
            # separate out multiple expressions.
            for expression in line.strip(",").split(","):
                expression = expression.strip()
                if not expression:
                    continue

                # See if this enum value is being assigned rather than implicit.
                match = re.match(r"^UC_(?P<id>\w+)\s*=\s*(?P<expr>.+)$", expression)
                if match:
                    # Enum value is assigned. Whatever's on the right-hand side, any
                    # names it references must already be defined.
                    name = "UC_" + match.group("id")
                    raw_value = match.group("expr")
                    try:
                        processed_value = eval(raw_value, resolved_values)
                    except NameError as nerr:
                        logging.error(
                            "Failed to resolve %r on line %d: %s", name, lineno, nerr
                        )
                        continue
                    resolved_values[name] = processed_value
                    next_enum_value = processed_value + 1
                else:
                    # Not an explicit assignment. Expect this expression to be just a
                    # single identifier.
                    match = re.match(r"^UC_(\w+)$", expression)
                    if match:
                        name = match.group(1)
                        resolved_values["UC_" + name] = next_enum_value
                        next_enum_value += 1
                    else:
                        raise SyntaxError(
                            "Couldn't match any expression type to: %r" % expression
                        )

    for name, raw_value in raw_matches.items():
        # Convert any remaining values that are still unresolved. This usually only
        # applies to #define macros that reference other constants.
        if name not in resolved_values:
            resolved_values[name] = eval(raw_value, resolved_values)

    return resolved_values


def generate_constants_for_file(header_file, output_file):
    """Generate a constants file from a Unicorn header.

    Arguments:
        header_file (str):
            The path to the source file header where the constants are defined. Ideally
            this is an absolute path.
        output_file (str):
            The path to the Lua file to create that'll contain these defined constants.
    """
    header_file = os.path.abspath(header_file)
    logging.info("Processing file: %s", header_file)

    all_value_pairs = parse_header_file(header_file)
    if not all_value_pairs:
        logging.error("No constants found in header, refusing to write to output file.")
        return

    with open(output_file, "w") as out_fd:
        out_fd.write(
            GENERATED_FILE_TEMPLATE.format(
                header_file=header_file,
                now=datetime.datetime.now(),
                n_values=len(all_value_pairs),
                slug=os.path.splitext(os.path.basename(header_file))[0].lower(),
                values=",\n".join(
                    '    {"%s", %s}' % kv for kv in sorted(all_value_pairs.items())
                ),
            )
        )

    logging.info("Finished. Found %d constant(s) in file.", len(all_value_pairs))


def main():
    logging.basicConfig(level=logging.INFO, format="[%(levelname)-5s] %(message)s")
    if len(sys.argv) != 3:
        logging.error(
            "Script takes two arguments, the path to a header file and the path to the"
            " C++ file to generate."
        )
        return 1

    logging.info("Generating `%s`...", sys.argv[2])
    generate_constants_for_file(os.path.abspath(sys.argv[1]), sys.argv[2])
    return 0


if __name__ == "__main__":
    sys.exit(main())
