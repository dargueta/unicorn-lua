"""Generate constants files from the Unicorn headers.

This is heavily borrowed from the script in the Unicorn source repo, except modified to
work with an installed library rather than from the source code. The headers must be
present, but that's all that's required.
"""

import configparser
import datetime
import logging
import os
import sys

import pycparser
from pycparser import c_ast
from pycparser import plyparser

HERE = os.path.dirname(__file__)


def evaluate_constant(node, enum_item):
    # type: (c_ast.Enum, c_ast.Enumerator) -> int
    """Evaluate a pycparser.c_ast.Constant object into an integer."""
    if enum_item.value.type != "int":
        raise NotImplementedError(
            "Unsupported datatype `%s` for enum item %s::%s."
            % (enum_item.value.type, node.name, enum_item.name)
        )
    return int(enum_item.value.value)


def evaluate_binop_expression(node, enum_item):
    # type: (c_ast.Enum, c_ast.Enumerator) -> int
    """Evaluate `X << Y` where X and Y are integer constants."""
    if enum_item.value.op != "<<":
        raise NotImplementedError(
            '%s::%s is defined using an unsupported operator: "%s"'
            % (node.name, enum_item.name, enum_item.value.op)
        )
    lhs = enum_item.value.left
    rhs = enum_item.value.right
    return int(lhs.value) << int(rhs.value)


GENERATED_FILE_TEMPLATE = """\
/** Autogenerated from installed Unicorn header files. DO NOT EDIT.
 *
 * Source: {header_file}
 * Generated: {now:%Y-%m-%d %I:%M %p}
 *
 * @file {slug}.cpp
 */

#include <unicorn/unicorn.h>

#include "unicornlua/lua.h"
#include "unicornlua/utils.h"

static const struct NamedIntConst kConstants[] {{
    {values},
    {{NULL, 0}}
}};

extern "C" UNICORN_EXPORT int luaopen_unicorn_{slug}(lua_State *L) {{
    lua_createtable(L, 0, {n_values});
    load_int_constants(L, kConstants);
    return 1;
}}
"""


class EnumVisitor(c_ast.NodeVisitor):
    """Node visitor for extracting enums from a header file."""

    def __init__(self):
        self.enums = {}

    def visit_Enum(self, node):
        # type: (c_ast.Enum) -> None
        next_value = 0
        all_enum_values = {}

        for enum_item in node.values:
            if enum_item.value is None:
                value = next_value
            elif isinstance(enum_item.value, c_ast.ID):
                # Enum value is assigned to another value; assume it's a preexisting
                # enum value.
                if enum_item.value.name not in all_enum_values:
                    raise ValueError(
                        "Enum item `%s::%s` references unrecognized identifier `%s`."
                        % (node.name, enum_item.name, enum_item.value.name)
                    )
                value = all_enum_values[enum_item.value.name]
            elif isinstance(enum_item.value, c_ast.Constant):
                value = evaluate_constant(node, enum_item)
            elif isinstance(enum_item.value, c_ast.BinaryOp):
                value = evaluate_binop_expression(node, enum_item)
            else:
                raise TypeError(
                    "Unexpected node type when processing enum item `%s::%s`: %r"
                    % (node.name, enum_item.name, enum_item.value)
                )
            next_value = value + 1
            all_enum_values[enum_item.name] = value
        self.enums[node.name] = all_enum_values


def get_gcc_predefines():
    """Get a dict of macros we need to predefine for this platform.

    Preprocessing a header file will fail on some platforms because the Python C parser
    can't find identifiers defined internally by the compiler. By defining them
    ourselves in the call to GCC we can hack our way around this problem for any
    platform, albeit a bit inelegantly.
    """
    config = configparser.ConfigParser(default_section="common")
    config.read(os.path.join(HERE, "gcc_predefs.ini"))

    predefs = config.defaults()
    if config.has_section(sys.platform):
        predefs.update(dict(config.items(sys.platform)))
    return predefs


def generate_constants_for_file(header_file, output_file):
    # type: (str, str) -> bool
    """Generate a constants file from a Unicorn header.

    Arguments:
        header_file (str):
            The path to the source file header where the constants are defined. Ideally
            this is an absolute path.
        output_file (str):
            The path to the Lua file to create that'll contain these defined constants.

    Returns:
        bool: True if the operation succeeded, False otherwise.
    """
    header_file = os.path.abspath(header_file)
    logging.info("Processing file: %s", header_file)

    predefs = get_gcc_predefines()
    command_parameters = ["-E", "-std=c11"]
    for name, value in predefs.items():
        command_parameters.extend(("-D", "%s=%s" % (name, value)))

    try:
        ast = pycparser.parse_file(
            header_file, use_cpp=True, cpp_path="gcc", cpp_args=command_parameters
        )
    except plyparser.ParseError as err:
        logging.error(
            "%s while processing `%s`: %s", type(err).__name__, header_file, err
        )
        return False

    enum_visitor = EnumVisitor()
    enum_visitor.visit(ast)

    all_value_pairs = {}

    for values in enum_visitor.enums.values():
        all_value_pairs.update(values)

    with open(output_file, "w") as out_fd:
        out_fd.write(
            GENERATED_FILE_TEMPLATE.format(
                header_file=header_file,
                now=datetime.datetime.now(),
                n_values=len(all_value_pairs),
                slug=os.path.splitext(os.path.basename(header_file))[0].lower(),
                values=",\n".join(
                    '    {"%s", %s}' % kv for kv in sorted(all_value_pairs.items())
                ),
            )
        )

    logging.info("Finished. Found %d enum(s) in file.", len(enum_visitor.enums))
    return True


def main():
    # type: () -> int
    logging.basicConfig(level=logging.WARNING, format="[%(levelname)-5s] %(message)s")
    if len(sys.argv) != 3:
        logging.error(
            "Script takes two arguments, the path to a header file and the path to the"
            " Lua file to generate."
        )
        return 1

    logging.info("Generating `%s`...", sys.argv[2])
    if generate_constants_for_file(os.path.abspath(sys.argv[1]), sys.argv[2]):
        return 0
    return 1


if __name__ == "__main__":
    sys.exit(main())
