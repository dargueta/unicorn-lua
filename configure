#!/usr/bin/env python3

import argparse
import collections
import logging
import os
import shutil
import subprocess
import sys


LOG = logging.getLogger(__name__)
HOME = os.path.expanduser("~")
HERE = os.path.abspath(os.path.dirname(__file__))


SUPPORTED_LUA_VERSIONS = {
    "5.1": "5.1",
    "5.2": "5.2",
    "5.3": "5.3",
    "luajit": "2.0",
    "luajit2.0": "2.0",
}


SPECIFIC_VERSIONS = {
    "5.1": "5.1.5",
    "5.2": "5.2.3",
    "5.3": "5.3.5",
    "luajit": "2.0.5",
    "luajit2.0": "2.0.5",
}


PLATFORM_ALIASES = {
    "linux": "linux",
    "darwin": "macosx",
    "win32": "mingw",
    "cygwin": "posix",
}


CONSTANTS_FILE_SLUGS = ["arm", "arm64", "m68k", "mips", "sparc", "x86"]

DEFAULT_LUAROCKS_VERSION = "3.2.1"
DEFAULT_LUA_VERSION = "5.3"
REQUIRED_ROCKS = {"busted", "lcurses"}

# Detect if we're in a CI environment. This works for Travis, CircleCI, and
# AppVeyor. (AppVeyor uses both "True" and "true" hence this .lower() fiddling.)
IN_CI_ENVIRONMENT = os.getenv("CI", "").lower() == "true"


class ErrorExit(Exception):
    pass


def run(*args, text=True, **kwargs):
    kwargs.setdefault("stderr", subprocess.PIPE)
    LOG.debug("Executing script: %r", args[0])
    try:
        rval = subprocess.check_output(*args, **kwargs)
    except subprocess.CalledProcessError as exc:
        LOG.error("Called process `%s` failed.", " ".join(args[0]))
        print(exc.stderr.decode("utf-8"))
        raise

    if text:
        return rval.decode("utf-8")
    return rval


def find_executables():
    return {
        "locate": shutil.which("locate"),
        "lua": shutil.which("lua"),
        "lenv": shutil.which("lenv"),
        "perl": shutil.which("perl"),
        "luarocks": shutil.which("luarocks"),
    }


def parse_args():
    parser = argparse.ArgumentParser()

    # Use different defaults if we're running in a CI environment like Travis or
    # CircleCI.
    if IN_CI_ENVIRONMENT:
        LOG.info("CI enviornent detected, altering script defaults.")
        default_lua_version = os.environ["LUA_VERSION"]
        default_log_level = logging.DEBUG
    else:
        default_lua_version = None
        default_log_level = logging.INFO

    parser.add_argument(
        "--verbose",
        action="store_const",
        const=logging.DEBUG,
        default=default_log_level,
        dest="logging_level",
        help="Enable debug logging. Only useful for debugging this script.",
    )
    parser.add_argument(
        "--install-path",
        metavar="PATH",
        help="The directory to install the compiled Lua library into. Defaults to the"
        " first directory in the OS's Lua's `packages.cpath`.",
    )
    parser.add_argument(
        "--lua-headers",
        metavar="PATH",
        help="The path to the directory holding the LUa header files.",
    )
    parser.add_argument(
        "--lua-lib", metavar="PATH", help="The path to the Lua shared library file."
    )
    parser.add_argument(
        "--luarocks-version",
        metavar="VERSION",
        default=DEFAULT_LUAROCKS_VERSION,
        help="The version of LuaRocks to use when installing Lua as a virtual"
        " environment. Ignored if --use-venv is not set.",
    )
    parser.add_argument(
        "--uc-headers",
        metavar="PATH",
        help="The path to the directory holding the Unicorn header files.",
    )
    parser.add_argument(
        "--uc-lib", metavar="PATH", help="The path to the Unicorn shared library file."
    )
    parser.add_argument(
        "--use-venv",
        action="store_true",
        help="Use a virtual environment instead of the OS's Lua. This allows you to use"
        " a different version of Lua than your OS, or isolate changes to a copy of your"
        " OS's Lua.",
    )
    parser.add_argument(
        "--venv-version",
        metavar="VERSION",
        dest="venv_version",
        choices=tuple(SUPPORTED_LUA_VERSIONS),
        default=default_lua_version,
        help="The Lua version to use in the virtual environment. If not given, defaults"
        " to the OS's Lua's version, or %s if Lua isn't installed at all. Implies"
        " --use-venv. Supported values: %s"
        % (DEFAULT_LUA_VERSION, ", ".join(SUPPORTED_LUA_VERSIONS)),
    )
    return parser.parse_args()


def get_system_lua_version(exe_paths):
    lua_exe = exe_paths["lua"]
    if not lua_exe:
        raise ErrorExit(
            "Lua not installed on OS or not in PATH environment variable. You must use"
            " a virtual environment (see --use-venv) or install it on your OS."
        )
    _lua, version, *_rest = run([lua_exe, "-v"]).split()
    return version


def get_library_file_extension(lua_exe_path="lua"):
    output = run([lua_exe_path, "-e", "print(package.cpath)"])
    paths = [p.strip() for p in output.split(";") if p and not p.isspace()]

    # Each path with a wildcard ("?") in it should end with the system's shared library
    # file extension.
    extensions = {os.path.splitext(p)[1].lstrip(".") for p in paths if "?" in p}

    if not extensions:
        raise ErrorExit("Couldn't determine file extension for shared libraries.")
    if len(extensions) > 1:
        raise ErrorExit(
            "More than one possible file extension for shared libraries found: "
            + ", ".join("`%s`" % e for e in sorted(extensions))
        )

    ext = extensions.pop().lstrip(".")
    LOG.debug("Inferred shared library file extension: `%s`", ext)
    return ext


def generate_cmake_parameters(args, install_version, platform):
    is_luajit = args.venv_version.startswith("luajit")
    short_version = install_version.rpartition(".")[0]
    return collections.OrderedDict(
        (
            ("LUA_FULL_VERSION", install_version),
            ("LUA_SHORT_VERSION", short_version),
            ("IS_LUAJIT", "YES" if is_luajit else "NO"),
            ("USE_VIRTUALENV", "YES" if args.use_venv else "NO"),
            ("DETECTED_LUA_PLATFORM", platform),
            ("LUAROCKS_VERSION", args.luarocks_version),
        )
    )


def main():
    args = parse_args()
    logging.basicConfig(
        format="[%(levelname)-5s] %(message)s", level=args.logging_level
    )
    exe_paths = find_executables()

    lua_platform = PLATFORM_ALIASES.get(sys.platform)
    if not lua_platform:
        LOG.warning("OS platform potentially unsupported: %r", sys.platform)
        lua_platform = "generic"

    if args.venv_version:
        args.use_venv = True

    if args.use_venv:
        if args.venv_version in SPECIFIC_VERSIONS:
            install_version = SPECIFIC_VERSIONS[args.venv_version]
        else:
            raise ErrorExit(
                "Unsupported Lua version: %r. Use --help to see supported versions."
                % args.venv_version
            )
        LOG.info("Using virtual environment, Lua %s", install_version)
    else:
        install_version = get_system_lua_version(exe_paths)
        LOG.info("Using OS installation, Lua %s", install_version)

    LOG.info("Generating Makefile parameters...")
    makefile_params = generate_cmake_parameters(args, install_version, lua_platform)
    with open("configuration.cmake.txt", "w") as fd:
        fd.write("\n".join('set(%s "%s")' % kv for kv in makefile_params.items()))

    # Remove all build artifacts from a previous build, since we're probably switching
    # Lua versions.
    LOG.info("Cleaning up...")
    run(["make", "clean"])


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        LOG.error("Killed.")
        sys.exit(2)
    except ErrorExit as exc:
        LOG.error(str(exc))
        sys.exit(1)
    else:
        sys.exit(0)
