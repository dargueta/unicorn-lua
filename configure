#!/usr/bin/env python3

import argparse
import configparser
import logging
import os
import shutil
import subprocess
import sys


LOG = logging.getLogger(__name__)
HERE = os.path.abspath(os.path.dirname(__file__))

CONFIG = configparser.ConfigParser(interpolation=None)
CONFIG.read(os.path.join(HERE, "tools", "lua_settings.ini"))


SUPPORTED_LUA_VERSIONS = tuple(CONFIG["supported_versions"].keys())
SPECIFIC_VERSIONS = CONFIG["specific_versions"]
PLATFORM_ALIASES = CONFIG["platform_targets"]
DEFAULT_LUAROCKS_VERSION = CONFIG["luarocks"]["default_version"]
DEFAULT_LUA_VERSION = CONFIG["lua"]["default_version"]


# Detect if we're in a CI environment. This works for Travis, CircleCI, and
# AppVeyor. (AppVeyor uses both "True" and "true" hence this .lower() fiddling.)
IN_CI_ENVIRONMENT = os.getenv("CI", "").lower() == "true"


class ErrorExit(Exception):
    pass


def run(*args, text=True, **kwargs):
    kwargs.setdefault("stderr", subprocess.PIPE)
    LOG.debug("Executing script: %r", args[0])
    try:
        rval = subprocess.check_output(*args, **kwargs)
    except subprocess.CalledProcessError as exc:
        LOG.error("Called process `%s` failed.", " ".join(args[0]))
        print(exc.stderr.decode("utf-8"))
        raise

    if text:
        return rval.decode("utf-8")
    return rval


def parse_args():
    parser = argparse.ArgumentParser()

    # Use different defaults if we're running in a CI environment like Travis or
    # CircleCI.
    if IN_CI_ENVIRONMENT:
        LOG.info("CI enviornent detected, altering script defaults.")
        default_log_level = logging.DEBUG
    else:
        default_log_level = logging.INFO

    parser.add_argument(
        "--verbose",
        action="store_const",
        const=logging.DEBUG,
        default=default_log_level,
        dest="logging_level",
        help="Enable debug logging. Only useful for debugging this script.",
    )
    parser.add_argument(
        "--build-type",
        metavar="TYPE",
        help="The type of settings to use when building. Can be `debug` or `release`.",
        choices=["debug", "release"],
        default="debug",
    )
    parser.add_argument(
        "--install-path",
        metavar="PATH",
        help="The directory to install the compiled Lua library into. Defaults to the"
        " first directory in Lua's `packages.cpath`.",
    )
    parser.add_argument(
        "--lua-lib", metavar="PATH", help="The path to the Lua library file."
    )
    parser.add_argument(
        "--uc-headers",
        metavar="PATH",
        help="The path to the directory holding the Unicorn header files.",
    )
    parser.add_argument(
        "--uc-lib", metavar="PATH", help="The path to the Unicorn shared library file."
    )
    parser.add_argument(
        "--use-venv", action="store_true", default=False
    )
    parser.add_argument(
        "--lua-exe-path",
        metavar="PATH",
        help="The path to the Lua executable to use for testing. Defaults to the"
        " system's Lua installation.",
        default=shutil.which("lua"),
    )
    parser.add_argument(
        "--luarocks-path",
        metavar="PATH",
        help="The path to the LuaRocks executable to install libraries with. Defaults"
        " to the system's LuaRocks executable.",
        default=shutil.which("luarocks"),
    )
    parser.add_argument(
        "--lua-headers",
        metavar="PATH",
        help="The path to the Lua headers files.",
    )
    parser.add_argument(
        "--lua-library",
        metavar="PATH",
        help="The path to the Lua library to use for linking.",
    )
    return parser.parse_args()


def get_lua_version(lua_exe=shutil.which("lua")):
    if not lua_exe:
        raise ErrorExit(
            "Lua not installed on OS or not in PATH environment variable. You must use"
            " a virtual environment (see --use-venv) or install it on your OS."
        )
    _lua, version, *_rest = run([lua_exe, "-v"]).split()
    return version


def generate_cmake_parameters(args, install_version, platform):
    if args.use_venv:
        is_luajit = args.venv_version.startswith("luajit")
    else:
        # Do not support installing to LuaJIT on the OS platform
        is_luajit = False

    short_version = install_version.rpartition(".")[0]
    values = {
        "LUA_FULL_VERSION": install_version,
        "LUA_SHORT_VERSION": short_version,
        "IS_LUAJIT": "YES" if is_luajit else "NO",
        "LUAJIT_FULL_VERSION": SPECIFIC_VERSIONS["luajit"] if is_luajit else "",
        "LUAJIT_SHORT_VERSION": SUPPORTED_LUA_VERSIONS["luajit"] if is_luajit else "",
        "USE_VIRTUALENV": "YES" if args.use_venv else "NO",
        "DETECTED_LUA_PLATFORM": platform,
        "LUAROCKS_VERSION": args.luarocks_version,
        "BUILD_TYPE": args.build_type,
<<<<<<< HEAD
        "LUA_EXE": args.lua_path,
        "LUAROCKS_EXE": args.luarocks_path,
        # Need plural for compatibility with CMake
        "LUA_LIBRARIES": args.lua_library or "",
=======
        "IN_CI_ENVIRONMENT": "YES" if IN_CI_ENVIRONMENT else "NO",
>>>>>>> master
    }

    if args.uc_lib:
        values["UNICORN_LIBRARY"] = args.uc_lib
    if args.uc_headers:
        # Since we include using <unicorn/unicorn.h> we actually need the path to the
        # directory *above* the unicorn headers. If the user gave us a path to the
        # Unicorn directory, take its parent.
        if os.path.basename(args.uc_headers) == "unicorn":
            values["UNICORN_HEADERS_PATH"] = os.path.dirname(args.uc_headers)
        else:
            values["UNICORN_HEADERS_PATH"] = args.uc_headers

    return values


def main():
    args = parse_args()
    logging.basicConfig(
        format="[%(levelname)-5s] %(message)s", level=args.logging_level
    )

    lua_platform = PLATFORM_ALIASES.get(sys.platform)
    if not lua_platform:
        LOG.warning("OS platform potentially unsupported: %r", sys.platform)
        lua_platform = "generic"

    install_version = get_lua_version(args.lua_exe_path)
    if args.use_venv:
        LOG.info("Using virtual environment, Lua %s", install_version)
    else:
        LOG.info("Using OS installation, Lua %s", install_version)

    LOG.info("Generating CMake parameters...")
    cmake_params = generate_cmake_parameters(args, install_version, lua_platform)
    with open("configuration.cmake", "w") as fd:
        fd.write("\n".join('set(%s "%s")' % kv for kv in cmake_params.items()))

    # Remove all build artifacts from a previous build, since we're probably switching
    # Lua versions.
    build_dir = os.path.join(HERE, "build")
    LOG.info("Cleaning up...")
    if os.path.exists(build_dir):
        shutil.rmtree(build_dir)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        LOG.error("Killed.")
        sys.exit(2)
    except ErrorExit as exc:
        LOG.error(str(exc))
        sys.exit(1)
    else:
        sys.exit(0)
