#!/usr/bin/env python3

import argparse
import configparser
import logging
import os
import shutil
import subprocess
import sys


LOG = logging.getLogger(__name__)
HERE = os.path.abspath(os.path.dirname(__file__))

CONFIG = configparser.ConfigParser(interpolation=None)
CONFIG.read(os.path.join(HERE, "tools", "lua_settings.ini"))

SUPPORTED_LUA_VERSIONS = tuple(CONFIG["supported_versions"].keys())
SPECIFIC_VERSIONS = CONFIG["specific_versions"]
PLATFORM_ALIASES = CONFIG["platform_targets"]
DEFAULT_LUAROCKS_VERSION = CONFIG["luarocks"]["default_version"]
DEFAULT_LUA_VERSION = CONFIG["lua"]["default_version"]

# Detect if we're in a CI environment. This works for Travis, CircleCI, and
# AppVeyor. (AppVeyor uses both "True" and "true" hence this .lower() fiddling.)
IN_CI_ENVIRONMENT = os.getenv("CI", "").lower() == "true"


class ErrorExit(Exception):
    pass


def run(*args, text=True, **kwargs):
    kwargs.setdefault("stderr", subprocess.PIPE)
    LOG.debug("Executing script: %r", args[0])
    try:
        rval = subprocess.check_output(*args, **kwargs)
    except subprocess.CalledProcessError as exc:
        LOG.error("Called process `%s` failed.", " ".join(args[0]))
        print(exc.stderr.decode("utf-8"))
        raise

    if text:
        return rval.decode("utf-8")
    return rval


def parse_args():
    parser = argparse.ArgumentParser()

    # Use different defaults if we're running in a CI environment like Travis or
    # CircleCI.
    if IN_CI_ENVIRONMENT:
        LOG.info("CI enviornent detected, altering script defaults.")
        default_log_level = logging.DEBUG
    else:
        default_log_level = logging.INFO

    parser.add_argument(
        "--verbose",
        action="store_const",
        const=logging.DEBUG,
        default=default_log_level,
        dest="logging_level",
        help="Enable debug logging. Only useful for debugging this script.",
    )
    parser.add_argument(
        "--build-type",
        metavar="TYPE",
        help="The type of settings to use when building. Can be `debug` or `release`.",
        choices=["debug", "release"],
        default="debug",
    )
    parser.add_argument(
        "--install-path",
        metavar="PATH",
        help="The directory to install the compiled Lua library into. Defaults to the"
        " first directory in Lua's `packages.cpath`.",
    )
    parser.add_argument(
        "--lua-headers",
        metavar="PATH",
        help="The path to the directory holding the Lua header files.",
    )
    parser.add_argument(
        "--lua-lib", metavar="PATH", help="The path to the Lua library file."
    )
    parser.add_argument(
        "--luarocks-version",
        metavar="VERSION",
        default=DEFAULT_LUAROCKS_VERSION,
        help="The version of LuaRocks to use when installing Lua as a virtual"
        " environment. Ignored if --use-venv is not set.",
    )
    parser.add_argument(
        "--uc-headers",
        metavar="PATH",
        help="The path to the directory holding the Unicorn header files.",
    )
    parser.add_argument(
        "--uc-lib", metavar="PATH", help="The path to the Unicorn shared library file."
    )
    parser.add_argument(
        "--use-venv",
        action="store_true",
        help="Use a virtual environment instead of the OS's Lua. This allows you to use"
        " a different version of Lua than your OS, or isolate changes to a copy of your"
        " OS's Lua.",
    )
    parser.add_argument(
        "--venv-version",
        metavar="VERSION",
        dest="venv_version",
        choices=tuple(SUPPORTED_LUA_VERSIONS),
        default=DEFAULT_LUA_VERSION,
        help="The Lua version to use in the virtual environment. If not given, defaults"
        " to the OS's Lua's version, or %s if Lua isn't installed at all. Implies"
        " --use-venv. Supported values: %s"
        % (DEFAULT_LUA_VERSION, ", ".join(SUPPORTED_LUA_VERSIONS)),
    )
    return parser.parse_args()


def get_system_lua_version():
    lua_exe = shutil.which("lua")
    if not lua_exe:
        raise ErrorExit(
            "Lua not installed on OS or not in PATH environment variable. You must use"
            " a virtual environment (see --use-venv) or install it on your OS."
        )
    _lua, version, *_rest = run([lua_exe, "-v"]).split()
    return version


def generate_cmake_parameters(args, install_version, platform):
    if args.use_venv:
        is_luajit = args.venv_version.startswith("luajit")
    else:
        # Do not support installing to LuaJIT on the OS platform
        is_luajit = False

    short_version = install_version.rpartition(".")[0]
    values = {
        "LUA_FULL_VERSION": install_version,
        "LUA_SHORT_VERSION": short_version,
        "IS_LUAJIT": "YES" if is_luajit else "NO",
        "LUAJIT_FULL_VERSION": SPECIFIC_VERSIONS["luajit"] if is_luajit else "",
        "LUAJIT_SHORT_VERSION": SUPPORTED_LUA_VERSIONS["luajit"] if is_luajit else "",
        "USE_VIRTUALENV": "YES" if args.use_venv else "NO",
        "DETECTED_LUA_PLATFORM": platform,
        "LUAROCKS_VERSION": args.luarocks_version,
        "BUILD_TYPE": args.build_type,
    }

    if args.uc_lib:
        values["UNICORN_LIBRARY"] = args.uc_lib
    if args.uc_headers:
        # Since we include using <unicorn/unicorn.h> we actually need the path to the
        # directory *above* the unicorn headers. If the user gave us a path to the
        # Unicorn directory, take its parent.
        if os.path.basename(args.uc_headers) == "unicorn":
            values["UNICORN_HEADERS_PATH"] = os.path.dirname(args.uc_headers)
        else:
            values["UNICORN_HEADERS_PATH"] = args.uc_headers

    return values


def main():
    args = parse_args()
    logging.basicConfig(
        format="[%(levelname)-5s] %(message)s", level=args.logging_level
    )

    lua_platform = PLATFORM_ALIASES.get(sys.platform)
    if not lua_platform:
        LOG.warning("OS platform potentially unsupported: %r", sys.platform)
        lua_platform = "generic"

    if args.venv_version:
        args.use_venv = True

    if args.use_venv:
        if args.venv_version in SPECIFIC_VERSIONS:
            if args.venv_version.startswith("luajit"):
                install_version = SPECIFIC_VERSIONS["5.1"]
            else:
                install_version = SPECIFIC_VERSIONS[args.venv_version]
        else:
            raise ErrorExit(
                "Unsupported Lua version: %r. Use --help to see supported versions."
                % args.venv_version
            )
        LOG.info("Using virtual environment, Lua %s", install_version)
    else:
        install_version = get_system_lua_version()
        LOG.info("Using OS installation, Lua %s", install_version)

    LOG.info("Generating CMake parameters...")
    cmake_params = generate_cmake_parameters(args, install_version, lua_platform)
    with open("configuration.cmake", "w") as fd:
        fd.write("\n".join('set(%s "%s")' % kv for kv in cmake_params.items()))

    # Remove all build artifacts from a previous build, since we're probably switching
    # Lua versions.
    build_dir = os.path.join(HERE, "build")
    LOG.info("Cleaning up...")
    if os.path.exists(build_dir):
        shutil.rmtree(build_dir)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        LOG.error("Killed.")
        sys.exit(2)
    except ErrorExit as exc:
        LOG.error(str(exc))
        sys.exit(1)
    else:
        sys.exit(0)
