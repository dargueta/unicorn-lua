#!/usr/bin/env python3

import argparse
import collections
import fnmatch
import logging
import os
import shutil
import subprocess
import sys


LOG = logging.getLogger(__name__)
HERE = os.path.abspath(os.path.dirname(__file__))


SUPPORTED_LUA_VERSIONS = {
    "5.1": "5.1",
    "5.2": "5.2",
    "5.3": "5.3",
    "luajit": "2.0",
    "luajit2.0": "2.0",
}


SPECIFIC_VERSIONS = {
    "5.1": "5.1.5",
    "5.2": "5.2.3",
    "5.3": "5.3.5",
    "luajit": "2.0.5",
    "luajit2.0": "2.0.5",
}


PLATFORM_ALIASES = {
    "linux": "linux",
    "darwin": "macosx",
    "win32": "mingw",
    "cygwin": "posix",
}


CONSTANTS_FILE_SLUGS = ["arm", "arm64", "m68k", "mips", "sparc", "x86"]


LENV_ROOT = os.path.expanduser("~/.lenv")
LENV_EXE = os.path.join(LENV_ROOT, "bin", "lenv")
DEFAULT_LUA_VERSION = "5.3"
IN_CI_ENVIRONMENT = os.getenv("CI") == "true"
REQUIRED_ROCKS = {"busted", "lcurses"}
REQUIRED_PYTHON_LIBRARIES = ["pycparser"]


class ErrorExit(Exception):
    pass


def run(*args, text=True, **kwargs):
    kwargs.setdefault("stderr", subprocess.PIPE)
    LOG.debug("Executing script: %r", args[0])
    try:
        rval = subprocess.check_output(*args, **kwargs)
    except subprocess.CalledProcessError as exc:
        LOG.error("Called process `%s` failed.", " ".join(args[0]))
        print(exc.output.decode("utf-8"))
        raise

    if text:
        return rval.decode("utf-8")
    return rval


def find_executables():
    return {
        "locate": shutil.which("locate"),
        "lua": shutil.which("lua"),
        "lenv": shutil.which("lenv"),
        "perl": shutil.which("perl"),
        "luarocks": shutil.which("luarocks"),
    }


def parse_args():
    parser = argparse.ArgumentParser()

    # Pull default Lua version from the environment if we're running on a CI. This works
    # for Travis and CircleCI.
    if IN_CI_ENVIRONMENT:
        default_lua_version = os.environ["LUA_VERSION"]
        default_uc_lib = "/usr/lib"
        default_uc_headers = "/usr/include"
    else:
        default_lua_version = None
        default_uc_lib = None
        default_uc_headers = None

    parser.add_argument(
        "-d",
        "--debug",
        action="store_const",
        const=logging.DEBUG,
        default=logging.INFO,
        dest="logging_level",
        help="Enable debug logging. Only useful for debugging this script.",
    )
    parser.add_argument(
        "--install-path",
        metavar="PATH",
        help="The directory to install the compiled Lua library into. Defaults to the"
        " first directory in the OS's Lua's `packages.cpath`.",
    )
    parser.add_argument(
        "--lua-headers", metavar="PATH", help="The path to the Lua headers to use."
    )
    parser.add_argument(
        "--lua-lib", metavar="PATH", help="The path to the Lua shared library."
    )
    parser.add_argument(
        "--uc-headers",
        metavar="PATH",
        help="The path to the Unicorn headers.",
        default=default_uc_headers,
    )
    parser.add_argument(
        "--uc-lib",
        metavar="PATH",
        help="The path to the Unicorn shared library.",
        default=default_uc_lib,
    )
    parser.add_argument(
        "--use-venv",
        action="store_true",
        help="Use a virtual environment instead of the OS's Lua. This allows you to use"
        " a different version of Lua than your OS, or isolate changes to a copy of your"
        " OS's Lua.",
    )
    parser.add_argument(
        "--venv-version",
        metavar="VERSION",
        dest="venv_version",
        choices=tuple(SUPPORTED_LUA_VERSIONS),
        default=default_lua_version,
        help="The Lua version to use in the virtual environment. If not given, defaults"
        " to the OS's Lua's version, or %s if Lua isn't installed at all. Implies"
        " --use-venv. Supported values: %s"
        % (DEFAULT_LUA_VERSION, ", ".join(SUPPORTED_LUA_VERSIONS)),
    )
    return parser.parse_args()


def get_system_lua_version(lua_exe):
    _lua, version, *_rest = run([lua_exe, "-v"]).split()
    return version


def get_library_file_extension():
    output = run(["lua", "-e", "print(package.cpath)"])
    paths = [p.strip() for p in output.split(";") if p and not p.isspace()]

    # Each path with a wildcard ("?") in it should end with the system's shared library
    # file extension.
    extensions = {os.path.splitext(p)[1].lstrip(".") for p in paths if "?" in p}

    if not extensions:
        raise ErrorExit("Couldn't determine file extension for shared libraries.")
    if len(extensions) > 1:
        raise ErrorExit(
            "More than one possible file extension for shared libraries found: "
            + ", ".join("`%s`" % e for e in sorted(extensions))
        )

    ext = extensions.pop().lstrip(".")
    LOG.debug("Inferred shared library file extension: `%s`", ext)
    return ext


def get_default_installation_path():
    output = run(["lua", "-e", "print(package.cpath)"])
    paths = [p for p in output.split(";") if p and not p.isspace()]

    # Each path *ending* with "?.<extension>" will be an installation path we can use.
    # Only take the first one.
    extension = get_library_file_extension()
    install_dirs = [os.path.dirname(p) for p in paths if p.endswith("?." + extension)]

    if len(install_dirs) >= 1:
        LOG.debug("Inferred installation directory: " + install_dirs[0])
        return install_dirs[0]
    raise ErrorExit(
        "Couldn't find an installation path for C libraries. You must provide a path"
        " using the `--install-path` option."
    )


def recursive_enum_files(where, glob="*"):
    all_files = []
    for root, _dirnames, filenames in os.walk(where):
        all_files.extend(
            os.path.join(os.path.relpath(root, HERE), f)
            for f in fnmatch.filter(filenames, glob)
        )
    return all_files


def detect_x86_assembler():
    if shutil.which("nasm"):
        return "nasm", "-Wall -Werror"
    if shutil.which("yasm"):
        return "yasm", "-Werror --force-strict"
    return "", ""


def detect_mips_toolchain():
    if shutil.which("mips-linux-gnu-gcc"):
        # Standard Linux toolchain
        return "mips-linux-gnu-gcc", ""
    elif shutil.which("ct-ng"):
        # Crosstool-NG
        raise NotImplementedError("Crosstool-NG not fully supported yet")
    return "", ""


def generate_makefile_include(args, exe_paths, install_version, base_dir, platform):
    ext = get_library_file_extension()

    short_version = install_version.rpartition(".")[0]
    if float(short_version) >= 5.3:
        busted_cli_args = ""
    else:
        busted_cli_args = '--exclude-tags="int64only"'

    if args.use_venv:
        LOG.debug("Determining binary and library paths for virtual environment.")
        bin_root = os.path.join(base_dir, "bin")
        lib_root = os.path.join(base_dir, "lib")
        rocks_root = os.path.join(base_dir, "luarocks")
        lua_include = args.lua_headers or os.path.join(base_dir, "include")

        cpath = [
            os.path.join(lib_root, "lua", short_version, "?." + ext),
            os.path.join(rocks_root, "lib", "?." + ext),
        ]
    else:
        # Hopefully these are right...
        LOG.debug("Determining binary and library paths for system Lua.")
        bin_root = os.path.dirname(exe_paths["lua"])
        lib_root = args.uc_lib
        rocks_root = os.path.join("?")
        lua_include = args.lua_headers or os.path.join(
            os.path.dirname(args.uc_headers), "lua" + short_version
        )

        cpath = [
            os.path.join(lib_root, "lua", short_version, "?." + ext),
            os.path.join(rocks_root, "lib", "?." + ext),
        ]

        if not os.path.exists(lua_include):
            raise ErrorExit(
                "Expected Lua headers at `%s` but the directory doesn't exist. Your OS"
                " probably installed the binary and didn't build from source. Use"
                " --lua-headers to set the directory for Lua %s's headers, or use"
                " --use-venv to install a  separate version of Lua that ships with the"
                " headers. It won't modify your OS's Lua."
                % (lua_include, short_version)
            )

    x86_asm, x86_asm_flags = detect_x86_assembler()

    # Don't list any source files if the user doesn't have a supported x86
    # assembler. This avoids running commands like "-o output input".
    if x86_asm:
        LOG.debug("Found x86 assembler: %s", x86_asm)
        x86_source_files = " ".join(recursive_enum_files("docs", "*.asm"))
    else:
        LOG.warning(
            "No x86 assembler found, ignoring all *.asm files. Some example programs"
            " may not be available."
        )
        x86_source_files = ""

    mips_asm, mips_flags = detect_mips_toolchain()
    if mips_asm:
        LOG.info("Found MIPS toolchain: %s", mips_asm)
        mips_source_files = " ".join(recursive_enum_files("docs", "*.s"))
    else:
        LOG.warning(
            "No MIPS toolchain found, ignoring all *.s files. Some example programs may"
            " not be available."
        )
        mips_source_files = ""

    variables = collections.OrderedDict(
        (
            ("REPO_ROOT", HERE),
            ("SRC_ROOT", os.path.join("$(REPO_ROOT)", "src")),
            ("INCLUDE_BASE", os.path.join("$(REPO_ROOT)", "include")),
            ("BUILD_DIR", os.path.join("$(REPO_ROOT)", "build")),
            ("OBJECT_DIR", os.path.join("$(BUILD_DIR)", "obj")),
            ("INSTALL_STAGING_DIR", os.path.join("$(BUILD_DIR)", "unicorn")),
            ("LUA_VERSION", install_version),
            ("LUA_SHORT_VERSION", short_version),
            ("LUA_LIB_PATH", lib_root),
            ("LUA_INCLUDE_PATH", lua_include),
            ("LUA_EXE", os.path.join(bin_root, "lua")),
            ("UNICORN_LIB_PATH", args.uc_lib),
            ("UNICORN_INCLUDE_PATH", args.uc_headers),
            ("LUAROCKS_EXE", os.path.join(bin_root, "luarocks")),
            ("LUA_CUSTOM_CPATH", ";".join(cpath)),
            ("BUSTED_EXE", os.path.join(bin_root, "busted")),
            ("C_SOURCE_FILES", " ".join(recursive_enum_files("src", "*.c"))),
            ("C_HEADER_FILES", " ".join(recursive_enum_files("include", "*.h"))),
            (
                "LUA_SOURCE_FILES",
                " ".join(
                    os.path.join("$(INSTALL_STAGING_DIR)", os.path.basename(f))
                    for f in recursive_enum_files("src", "*.lua")
                ),
            ),
            (
                "LUA_AUTOGEN_FILES",
                " ".join(
                    os.path.join("$(INSTALL_STAGING_DIR)", slug + "_const.lua")
                    for slug in CONSTANTS_FILE_SLUGS
                ),
            ),
            ("X86_ASM_SOURCE_FILES", x86_source_files),
            ("MIPS_ASM_SOURCE_FILES", mips_source_files),
            ("BUSTED_CLI_ARGS", busted_cli_args),
            ("LIB_EXTENSION", ext),
            ("PLATFORM", platform),
            ("X86_ASM", x86_asm),
            ("X86_ASM_FLAGS", x86_asm_flags),
            ("MIPS_ASM", mips_asm),
            ("MIPS_ASM_FLAGS", mips_flags),
            ("INSTALLATION_PATH", args.install_path or get_default_installation_path()),
        )
    )

    LOG.debug("Writing Makefile include file.")
    with open("Makefile.in", "w") as fd:
        fd.write("\n".join("%s=%s" % kv for kv in variables.items()))
    LOG.debug("Done writing `Makefile.in`")


def locate_unicorn_headers(exe_paths):
    if not exe_paths["locate"]:
        raise ErrorExit(
            "Can't infer Unicorn header path, you must pass --uc-headers to this"
            " command."
        )

    LOG.info("Locating Unicorn headers...")
    try:
        out = run([exe_paths["locate"], "unicorn/unicorn.h"])
    except subprocess.CalledProcessError:
        out = ""

    paths = [ln.strip() for ln in out.splitlines() if not ln.isspace()]
    if len(paths) > 1:
        raise ErrorExit(
            "--uc-headers not given, found multiple Unicorn header file candidates:"
            "\n- " + "\n- ".join(paths)
        )
    elif not paths:
        raise ErrorExit(
            "Can't infer Unicorn header path, you must pass --uc-headers to this"
            " command."
        )

    # Strip off last two path components, the unicorn/unicorn.h part. We
    # only need the containing directory.
    path = os.path.dirname(paths[0])
    LOG.debug("Inferred Unicorn header path: %s", path)
    return path


def set_up_venv(args, exe_paths, lua_platform):
    if not exe_paths["perl"]:
        raise ErrorExit(
            "Perl doesn't seem to be installed, but is required by lenv. Please"
            " install it."
        )
    if not os.path.exists(LENV_EXE):
        raise ErrorExit(
            "--use-venv is set but can't find `lenv` executable. Please install it,"
            " following the instructions here: https://github.com/mah0x211/lenv"
        )
    if not args.venv_version:
        if not exe_paths["lua"]:
            LOG.warning(
                "Can't find Lua executable and desired version number not given."
                " Defaulting to %s.",
                DEFAULT_LUA_VERSION,
            )
            args.venv_version = DEFAULT_LUA_VERSION
        else:
            LOG.info("No version number given, defaulting to the OS's Lua version.")
            system_full_version = get_system_lua_version(exe_paths["lua"])
            args.venv_version = system_full_version.rpartition(".")[0]
            LOG.info("Using Lua version %s", args.venv_version)

    LOG.info("Enumerating available Lua versions...")
    run([LENV_EXE, "fetch"])

    if args.venv_version in SPECIFIC_VERSIONS:
        install_version = SPECIFIC_VERSIONS[args.venv_version]
    else:
        raise ErrorExit(
            "Unsupported Lua version: %r. Use --help to see supported versions."
            % args.venv_version
        )

    if args.venv_version.startswith("luajit"):
        # User wants to use LuaJIT, which requires a separate command.
        LOG.info("Installing LuaJIT %s", install_version)
        run([LENV_EXE, "install-lj", install_version])
        lua_base_dir = os.path.join(LENV_ROOT, "luajit", install_version)
    else:
        # Regular Lua
        LOG.info("Installing Lua %s", install_version)
        run([LENV_EXE, "install", install_version, lua_platform])
        lua_base_dir = os.path.join(LENV_ROOT, "lua", install_version)

    return install_version, lua_base_dir


def detect_os_lua(exe_paths):
    lua_exe = exe_paths["lua"]
    if not lua_exe:
        raise ErrorExit(
            "Lua not installed on OS or not in PATH environment variable. You must use"
            " a virtual environment (see --use-venv) or install it on your OS."
        )
    return get_system_lua_version(lua_exe), os.path.dirname(lua_exe)


def locate_unicorn_library(exe_paths):
    if not exe_paths["locate"]:
        raise ErrorExit(
            "Can't infer Unicorn library path, you must pass --uc-lib to this command."
        )
    LOG.info("Locating Unicorn library...")
    try:
        out = run([exe_paths["locate"], "libunicorn.a"])
    except subprocess.CalledProcessError:
        out = ""

    paths = [ln.strip() for ln in out.splitlines() if not ln.isspace()]
    if len(paths) > 1:
        raise ErrorExit(
            "--uc-lib not given, found multiple Unicorn lib candidates: "
            "\n- " + "\n- ".join(paths)
        )
    elif not paths:
        raise ErrorExit(
            "Can't infer Unicorn library path, you must pass --uc-lib to this command."
        )

    # Strip off last two path components, the unicorn/unicorn.h part. We only need the
    # containing directory.
    path = os.path.dirname(paths[0])
    LOG.debug("Inferred Unicorn library path: %s", path)
    return path


def main():
    args = parse_args()
    logging.basicConfig(
        format="[%(levelname)-5s] %(message)s", level=args.logging_level
    )
    exe_paths = find_executables()

    lua_platform = PLATFORM_ALIASES.get(sys.platform)
    if not lua_platform:
        LOG.warning("OS platform potentially unsupported: %r", sys.platform)
        lua_platform = "generic"

    if not args.uc_headers:
        args.uc_headers = locate_unicorn_headers(exe_paths)
    if not args.uc_lib:
        args.uc_lib = locate_unicorn_library(exe_paths)
    if args.venv_version:
        args.use_venv = True

    if args.use_venv:
        install_version, lua_base_dir = set_up_venv(args, exe_paths, lua_platform)
        LOG.info("Using virtual environment, Lua %s", install_version)
        luarocks_exe = os.path.join(lua_base_dir, "bin", "luarocks")
    else:
        install_version, lua_base_dir = detect_os_lua(exe_paths)
        LOG.info("Using OS installation, Lua %s", install_version)

        luarocks_exe = exe_paths["luarocks"]
        if not luarocks_exe:
            raise ErrorExit("Can't find `luarocks` executable. Please install it.")

    LOG.info("Generating Makefile parameters...")
    generate_makefile_include(
        args, exe_paths, install_version, lua_base_dir, lua_platform
    )

    LOG.info("Installing required Lua rocks...")
    for i, rock in enumerate(REQUIRED_ROCKS, start=1):
        LOG.info("Rock %d of %d: %s", i, len(REQUIRED_ROCKS), rock)

        # Use --local when installing rocks because otherwise the installation would be
        # system-wide and require sudo privileges.
        run([luarocks_exe, "install", "--local", rock])

    LOG.info("Installing required Python libraries...")

    # Install dependencies locally so we don't need sudo to install packages.
    run(["pip3", "install", "--user"] + REQUIRED_PYTHON_LIBRARIES)

    # Remove all build artifacts from a previous build, since we're probably switching
    # Lua versions.
    LOG.info("Cleaning up...")
    run(["make", "clean"])


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        LOG.error("Killed.")
        sys.exit(2)
    except ErrorExit as exc:
        LOG.error(str(exc))
        sys.exit(1)
    else:
        sys.exit(0)
