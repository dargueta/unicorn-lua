// Copyright (C) 2017-2024 by Diego Argueta
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

/// @submodule unicorn_c_

#include "unicornlua/register_types.h"
#include "unicornlua/registers.h"
#include "unicornlua/utils.h"
#include <lua.h>
#include <lauxlib.h>
#include <stdint.h>


! for _, bits in ipairs({8, 16, 32, 64}) do
#define register__as_int$(bits)(ptr) (*((const int$(bits)_t *)(ptr)))
! end

! for _, bits in ipairs({32, 64}) do
#define register__as_float$(bits)(ptr)  (*((const uclua_float$(bits) *)(ptr)))
! end

! for _, conf in ipairs(int_arrays) do
#define register__as_$(conf.count)xi$(conf.bits)(ptr)  ((int$(conf.bits)_t *)(ptr))
! end

! for _, conf in ipairs(float_arrays) do
#define register__as_$(conf.count)xf$(conf.bits)(ptr)  ((uclua_float$(conf.bits) *)(ptr))
! end


size_t register__size_for_register_kind(enum RegisterDataType kind) {
    switch (kind) {
! for _, bits in ipairs({8, 16, 32, 64}) do
        case UL_REG_TYPE_INT$(bits): return $(string.format("%d", bits / 8));
! end
! for _, bits in ipairs({32, 64, 80}) do
        case UL_REG_TYPE_FLOAT$(bits): return $(string.format("%d", bits / 8));
! end
! for _, conf in ipairs(int_arrays) do
        case UL_REG_TYPE_INT$(conf.bits)_ARRAY_$(conf.count): return $(string.format("%d", conf.bits * conf.count / 8));
! end
! for _, conf in ipairs(float_arrays) do
        case UL_REG_TYPE_FLOAT$(conf.bits)_ARRAY_$(conf.count): return $(string.format("%d", conf.bits * conf.count / 8));
! end
        case UL_REG_TYPE_UNKNOWN:
            /* luaL_error(L, "Can't determine size of register type \"UNKNOWN\""); */
        default:
        /*
            luaL_error(
                L,
                "Can't determine size of register unrecognized register type %d.",
                kind
            );
        */
        return 0;
    }
}

! for _, conf in ipairs(int_arrays) do
void integer_array_$(conf.count)xi$(conf.bits)_to_table(lua_State *L, int$(conf.bits)_t *array)
{
    int i;

    lua_createtable(L, $(conf.count), 0);
    for (i = 0; i < $(conf.count); i++)
    {
        lua_pushinteger(L, i + 1);
        lua_pushinteger(L, (lua_Integer)array[i]);
        lua_settable(L, -3);
    }
}
! end

! for _, conf in ipairs(float_arrays) do
void float_array_$(conf.count)xf$(conf.bits)_to_table(lua_State *L, uclua_float$(conf.bits) *array)
{
    int i;

    lua_createtable(L, $(conf.count), 0);
    for (i = 0; i < $(conf.count); i++)
    {
        lua_pushinteger(L, i + 1);
        lua_pushnumber(L, (lua_Integer)array[i]);
        lua_settable(L, -3);
    }
}
! end


void register__push_to_lua(const struct Register *reg, lua_State *L) {
    switch (reg->kind) {
! for _, bits in ipairs({8, 16, 32, 64}) do
        case UL_REG_TYPE_INT$(bits):
            lua_pushinteger(L, register__as_int$(bits)(reg->data));
            break;
! end
! -- TODO: Add 80 to this list once we add support for 80-bit floats.
! for _, bits in ipairs({32, 64}) do
        case UL_REG_TYPE_FLOAT$(bits):
            lua_pushnumber(L, register__as_float$(bits)(reg->data));
            break;
! end
        case UL_REG_TYPE_FLOAT80:
            luaL_error(
                L,
                "Error: Writing 80-bit floating-point numbers is currently not supported."
                " See <https://github.com/dargueta/unicorn-lua/issues/15>."
            );
            break;
! for _, conf in ipairs(int_arrays) do
        case UL_REG_TYPE_INT$(conf.bits)_ARRAY_$(conf.count):
            integer_array_$(conf.count)xi$(conf.bits)_to_table(L, register__as_$(conf.count)xi$(conf.bits)(reg->data));
            break;
! end
! for _, conf in ipairs(float_arrays) do
        case UL_REG_TYPE_FLOAT$(conf.bits)_ARRAY_$(conf.count):
            float_array_$(conf.count)xf$(conf.bits)_to_table(L, register__as_$(conf.count)xf$(conf.bits)(reg->data));
            break;
! end
        case UL_REG_TYPE_UNKNOWN:
        default:
            luaL_error(
                L,
                "Can't return register of unknown type %d to Lua.",
                reg->kind
            );
    }
}


void register__from_lua(struct Register *reg, lua_State *L, int value_index, int kind_index) {
    int i;
    enum RegisterDataType kind = (enum RegisterDataType)lua_tointeger(L, kind_index);
    reg->kind = kind;

    switch (kind) {
! for _, bits in ipairs({8, 16, 32, 64}) do
        case UL_REG_TYPE_INT$(bits):
            *((int$(bits)_t *)reg->data) = (int$(bits)_t)lua_tointeger(L, value_index);
            break;
! end
! for _, bits in ipairs({32, 64}) do
        case UL_REG_TYPE_FLOAT$(bits):
            *((uclua_float$(bits) *)reg->data) =
                (uclua_float$(bits))lua_tonumber(L, value_index);
            break;
! end
! for _, conf in ipairs(int_arrays) do
        case UL_REG_TYPE_INT$(conf.bits)_ARRAY_$(conf.count):
            for (i = 0; i < $(conf.count); ++i) {
#if LUA_VERSION_NUM >= 503
                lua_geti(L, value_index, i + 1);
#else
                lua_pushinteger(L, i + 1);
                lua_gettable(L, value_index);
#endif
                ((int$(conf.bits)_t *)reg->data)[i] =
                    (int$(conf.bits)_t)lua_tointeger(L, -1);
                lua_pop(L, 1);
            }
            break;
! end
! for _, conf in ipairs(float_arrays) do
        case UL_REG_TYPE_FLOAT$(conf.bits)_ARRAY_$(conf.count):
            for (i = 0; i < $(conf.count); ++i) {
#if LUA_VERSION_NUM >= 503
                lua_geti(L, value_index, i + 1);
#else
                lua_pushinteger(L, i + 1);
                lua_gettable(L, value_index);
#endif
                ((uclua_float$(conf.bits) *)reg->data)[i] =
                    (uclua_float$(conf.bits))lua_tonumber(L, -1);
                lua_pop(L, 1);
            }
            break;
! end
        case UL_REG_TYPE_FLOAT80:
            luaL_error(
                L,
                "Error: Reading 80-bit floating-point numbers is currently not supported."
                " See <https://github.com/dargueta/unicorn-lua/issues/15>."
            );
            UL_UNREACHABLE_MARKER;
        case UL_REG_TYPE_UNKNOWN:
        default:
            luaL_error(L, "Invalid register type ID: %d", kind);
            UL_UNREACHABLE_MARKER;
    }
}

! -- NOTE: This *MUST* be kept in the same order as in register_types.template!
static const char *kRegisterDataTypeSlugs[] = {
    "UL_REG_TYPE_UNKNOWN",
! for _, bits in ipairs({8, 16, 32, 64}) do
    "UL_REG_TYPE_INT$(bits)",
! end
! for _, bits in ipairs({32, 64}) do
    "UL_REG_TYPE_FLOAT$(bits)",
! end
! for _, conf in ipairs(int_arrays) do
    "UL_REG_TYPE_INT$(conf.bits)_ARRAY_$(conf.count)",
! end
! for _, conf in ipairs(float_arrays) do
    "UL_REG_TYPE_FLOAT$(conf.bits)_ARRAY_$(conf.count)",
! end
    "UL_REG_TYPE_FLOAT80"
};


const char *register__type_id_to_slug(enum RegisterDataType kind)
{
    if (kind >= 0 && kind < ULINTERNAL_REG_TYPE_MAX)
        return kRegisterDataTypeSlugs[kind];
    return "Invalid register type ID";
}
